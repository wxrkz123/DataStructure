栈帧 stack frame

调用约定 calling convention

压入返回地址 

指令指针 instruction pointer  ip pc 寄存器

它的工作：IP寄存器里面 永远存储着 下一条 将要被执行的指令的内存地址

读取 addr
根据Address获取指令
执行
自动指向next指令地址
循环……

CALL 指令
1. 压入返回地址
2. 无条件跳转

main -》


IP->adddr         汇编指令                  对应C代码
0x1000         MOV[start_num], 10        start_num=10
0x1004          CALL  calc()            final_result = calculate_score(start_num);
0x1008          MOV(final_result),EAX   (return address )
0x100C          MOV EAX,0                  return 0;
0x2000 


1. 递归的步骤(Recursive Step) f(n) f(n-1) f(3)



AVL  

BalanceFactor(node) = Height(node.left) - Heigth(node.right)

该节点的左子树的高度，减去其右子树的高度。

BF(node) -1, 0, 1

BF = 1 （平衡因子）
BF = 0
BF = -1 

|BF| > 1 倾斜


树的高度 Height of a tree: 根节点的高度
节点的高度 Height of Node : 从该节点到其最远叶子节点的路径上所包含的边的数量或节点的数量。

计算一个非叶子节点N的高度：

Height(N) = 1 + max(height(N.leftChild, height(N.rightChild))
一个节点的高度，等于其所有子树中最高高度加上1， max函数是取左、右子树高度的最大值。


D 1
边 ： 高度从0开始计算

空节点 NULL 的高度 -1
叶子节点 高度： 0
计算公式
- 如果节点N为空： height(N) = -1
- 否则 height(N) = 1 + max(height(N.leftChild), height(N.rightChild))

D 2
节点

高度 从1 开始计算

空节点 NULL -》 0
叶子节点 高度 1
计算公式：
- 如果节点N为空： height(N) = 0
- 否则，height(N) = 1 + max(height(N.leftChild), height(N.rightChild)) 
   非叶子节点的高度 =  1+ 其左右子树中较高的那个高度


Height Depth
高度    深度

高度： 自底向上看。一个节点的高度是它到最远叶子节点的距离
深度： 自顶向下看。一个节点的深度是它到根节点的距离。


深度计算：
1. 根节点的深度永远是0
2. 任何其他节点的深度=其父节点的深度+1

节点值(Value)               高度(Height)                深度(Depth)             Note
30                          3                           0                       根节点，深度越小，高度越大
20                          2                           1                       中间层
40                          2                            1
10                          1                              2
25                          1                               2
35
50
树的深度等于数的高度-1 （如果高度从1开始计数），所以这Tree的深度是2
对于任何一棵树，根节点的深度最小（为零），高度最大
叶子节点的深度最大看，高度越小（为0或者1， 取决于D）



核心概念
1. 旋转 (Rotation)

旋转是一系列针对二叉搜索树中节点指针的重新赋值操作。其目的是在保持二叉搜索树性质不变的前提下，改变特定节点在树中的深度（depth），以满足自平衡树的高度平衡标准。这是一种局部操作，仅影响少量节点及其直接子节点。

失去平衡Root 根节点: 从新插入节点向上回溯时，第一个发现其平衡因子变为 +2 或 -2 的节点。

Pivot (枢轴/旋转轴心): 这通常是 Root 节点的子节点，并且位于走向新插入节点的路径上。在旋转过程中，Pivot 或其子节点将“旋转”到 Root 的位置，成为新的子树根节点。

2. 二叉搜索树性质 (Binary Search Tree Property)

旋转操作必须严格遵守的规则。对于树中的任意节点 N：

其左子树中所有节点的键值（key）都小于或等于 N 的键值。

其右子树中所有节点的键值都大于 N 的键值。

单次旋转 (Single Rotation)

单次旋转是基础的结构调整操作。

1. 左旋转 (Left Rotation)

条件：对节点 x 进行左旋转，其右子节点 y 不能为 null。

过程：

节点 y 的左子树将成为节点 x 的新右子树。具体操作是：将 y 的左子节点（设为 beta）的父指针指向 x，并将 x 的右子节点指针指向 beta。

节点 x 的父节点将成为节点 y 的父节点。具体操作是：更新 x 原父节点的子节点指针，使其指向 y。

节点 x 将成为节点 y 的左子节点。具体操作是：将 y 的左子节点指针指向 x，并将 x 的父指针指向 y。

结果：x 成为 y 的左子节点，y 取代了 x 的原始位置。x 的右子树被 y 的原左子树替换。

2. 右旋转 (Right Rotation)

条件：对节点 y 进行右旋转，其左子节点 x 不能为 null。

过程：（这是左旋转的对称操作）

节点 x 的右子树将成为节点 y 的新左子树。具体操作是：将 x 的右子节点（设为 beta）的父指针指向 y，并将 y 的左子节点指针指向 beta。

节点 y 的父节点将成为节点 x 的父节点。具体操作是：更新 y 原父节点的子节点指针，使其指向 x。

节点 y 将成为节点 x 的右子节点。具体操作是：将 x 的右子节点指针指向 y，并将 y 的父指针指向 x。

结果：y 成为 x 的右子节点，x 取代了 y 的原始位置。y 的左子树被 x 的原右子树替换。

双重旋转 (Double Rotation)

双重旋转是两次单次旋转的组合，用于处理单次旋转无法解决的特定失衡情况。

1. 左右旋转 (Left-Right Rotation)

触发条件：节点 z 出现失衡，且失衡是由向 z 的左子节点 y 的右子树中插入新节点引起的。

执行步骤：

对节点 y（z的左子节点）执行一次 左旋转。

对节点 z 本身执行一次 右旋转。

2. 右左旋转 (Right-Left Rotation)

触发条件：节点 z 出现失衡，且失衡是由向 z 的右子节点 y 的左子树中插入新节点引起的。

执行步骤：

对节点 y（z的右子节点）执行一次 右旋转。

对节点 z 本身执行一次 左旋转。




NIL 节点  哨兵节点 Sentinel Node
它不是NULL
红黑树中，如果一个节点没有左孩子或右孩子，那么我们用一个指向同一个、全局的、特殊的NIL节点的指针。

哑节点 Dummy node

它是红黑树真正的“叶子”

法则5：从任一指定节点出发，到达其所有后代NIL叶子节点的每一条路径上，所包含的黑色节点数量都是相同的。

这个相同数量——》 从该节点出发的 黑高（Black-Height）


一棵M阶的B树具有以下关键特性：

1. 多路性：每个节点最多可以拥有M个子节点
2. 平衡性：所有的叶子节点都位于同一层，这保证了查找操作的稳定性。
3. 有序性: 每个节点中的关键字都按照升序排列，并且节点中的关键字将子树分隔开来。例如，一个有两个关键字(k1, k2)的节点，它
会有三个子树，左边子树的所有值都小于k1, 中间子树的所有值介于k1和k2之间，右边子树的所有值都大于k2
   有序的区间划分
4. 对节点关键字数量的限制：
 - 根节点至少有两个子节点（除非它本身是叶子节点）
 - 非叶子节点（除根节点之外）至少有[M/2]个子节点。
 - 一个拥有K个子节点的非叶子节点包含k-1个关键字


为了维持这个特性，所有的插入和删除的操作必须要涉及到节点的分裂和合并。


计算M

阶数： 一个节点最多可以拥有的子节点数

   定义：M是指一个B树节点最多可以拥有的子节点（Children）的数量
   推论：B树中，任何一个节点的关键字（keys）数量总是比它的子节点数量少1
   结论：一个M阶的B树节点，最多可以拥有M-1个关键字

eg.
M=5
一个节点最多可以拥有5个子节点
一个节点最多可以拥有5-1个关键字

t(minDegree)最小度数
定义：t指的是一个非根节点最少必须拥有的子节点数量。这是为了保证B树不会因为节点内元素过少而导致树的高度过高。
计算公式：t由M计算得出，公式为：t = ⌈M/2⌉ 
符号 ⌈⌉ 向上取整 ceiling function 表示将除法结果中的小数部分直接进位到下一个整数。
推论：因为关键字数量比子节点数量少1
结论：所以，一个非根节点，必须拥有t-1个关键字

eg.
M=5
t = ⌈5/2⌉ = 3
一个非根节点最少要有3个子节点
一个非根节点最少要有3-1=2个关键字 



顶点 Vertex

无向图 undirected Graph

权重 Weight

带权图 Weighted Graph

有向无环图 Directed Acyclic Graph DAG

图密度 = 实际边数 / 所有可能存在的边数


邻接矩阵

定义数据结构:

1. 一个二维数组 graph[V][V] graph[i][j]
2. key[V]
3. mstSet[V] bool
4. parent[V]


邻接表+ 最小堆

{cost, Vertex}