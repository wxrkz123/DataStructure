<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>双向链表：终极CRUD演示 - 文档编辑器</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/petite-vue"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8f9fa; }
        .line-controls { opacity: 0; transition: opacity 0.2s ease-in-out; }
        .line-item:hover .line-controls { opacity: 1; }
    </style>
</head>

<body class="p-8">
<main id="app" v-scope @vue:mounted="init()" class="grid grid-cols-1 lg:grid-cols-2 gap-12 max-w-7xl mx-auto">

    <!-- ============================================= -->
    <!--          左侧：文档编辑器界面                 -->
    <!-- ============================================= -->
    <div class="bg-white p-8 rounded-2xl shadow-lg border border-slate-200">
        <header class="mb-8 pb-4 border-b border-slate-200">
            <h1 class="text-3xl font-bold text-slate-800">项目策划文档</h1>
            <p class="text-slate-500 mt-2">每一行都是一个链表节点。请尝试对它进行CRUD操作。</p>
        </header>

        <!-- 文档内容 (链表可视化) -->
        <div class="space-y-2">
            <div v-for="node in list.toArray()" :key="node.id" 
                 class="line-item flex items-center gap-4 p-2 rounded-lg transition-colors duration-200"
                 :class="{ 'bg-blue-100': currentNode === node }">
                
                <!-- 行号/光标 -->
                <div class="w-8 text-center font-mono text-slate-400">
                    <i v-if="currentNode === node" class="fas fa-caret-right text-blue-500 text-lg"></i>
                    <span v-else>{{ node.id + 1 }}</span>
                </div>

                <!-- 文本内容 / 编辑框 -->
                <div class="flex-grow">
                    <p v-if="editingNode !== node" class="text-slate-700 leading-relaxed">{{ node.value }}</p>
                    <input v-else type="text" v-model="node.value" @keyup.enter="saveEdit(node)" @blur="saveEdit(node)"
                           class="w-full px-2 py-1 bg-white border border-blue-400 rounded-md focus:outline-none ring-2 ring-blue-200">
                </div>

                <!-- 行内操作按钮 -->
                <div class="line-controls flex items-center gap-3 text-slate-500">
                    <button @click="insertAfter(node)" title="在此行后插入" class="hover:text-green-500"><i class="fas fa-plus"></i></button>
                    <button @click="startEditing(node)" title="编辑此行" class="hover:text-blue-500"><i class="fas fa-pencil-alt"></i></button>
                    <button @click="deleteNode(node)" title="删除此行" class="hover:text-red-500"><i class="fas fa-trash-alt"></i></button>
                </div>
            </div>
        </div>
        
        <!-- 全局操作 -->
        <div class="mt-8 pt-6 border-t border-slate-200 flex items-center justify-center gap-4">
            <button @click="moveUp()" class="px-6 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold rounded-full transition">光标上移 (Read)</button>
            <button @click="moveDown()" class="px-6 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold rounded-full transition">光标下移 (Read)</button>
        </div>
    </div>

    <!-- ============================================= -->
    <!--         右侧：终极CRUD教学模块                -->
    <!-- ============================================= -->
    <div class="bg-[#1e293b] text-slate-200 rounded-2xl p-8 shadow-lg sticky top-8 h-fit">
        <h3 class="text-xl font-bold text-white mb-4 flex items-center"><i class="fas fa-graduation-cap mr-3 text-sky-400"></i>双向链表 · CRUD 解析</h3>
        <div class="bg-black/20 p-4 rounded-lg space-y-4">
            <!-- 当前操作 -->
            <div>
                <p class="text-xs font-bold text-slate-400">当前操作</p>
                <p class="text-sky-400 font-bold text-lg">{{ info.title }}</p>
            </div>
            <!-- 详细描述 -->
            <div>
                 <p class="text-xs font-bold text-slate-400">详细描述</p>
                 <p class="text-sm text-slate-300 leading-relaxed">{{ info.description }}</p>
            </div>
            <!-- 指针变化 -->
            <div v-if="info.pointers.length > 0">
                 <p class="text-xs font-bold text-slate-400">指针变化 (核心代码)</p>
                 <div class="mt-1 space-y-1 text-xs font-mono">
                    <p v-for="p in info.pointers" class="bg-black/20 p-2 rounded-md" v-html="p"></p>
                 </div>
            </div>
            <!-- 性能分析 -->
            <div>
                 <p class="text-xs font-bold text-slate-400">性能分析 (Big O)</p>
                 <p class="text-sm text-slate-300" v-html="info.complexity"></p>
            </div>
        </div>
    </div>
</main>


<script>
    // --- 数据结构定义 (无变化) ---
    let nodeIdCounter = 0;
    class Node { constructor(value) { this.id = nodeIdCounter++; this.value = value; this.next = null; this.prev = null; } }
    class DoublyLinkedList {
        constructor() { this.head = null; this.tail = null; this.size = 0; }
        append(value) { const newNode = new Node(value); if (!this.head) { this.head = this.tail = newNode; } else { this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } this.size++; }
        insertAfter(node, value) { if (!node) return; const newNode = new Node(value); newNode.next = node.next; newNode.prev = node; if (node.next) { node.next.prev = newNode; } else { this.tail = newNode; } node.next = newNode; this.size++; return newNode; }
        delete(node) { if (!node) return; if (node.prev) { node.prev.next = node.next; } else { this.head = node.next; } if (node.next) { node.next.prev = node.prev; } else { this.tail = node.prev; } this.size--; }
        toArray() { const arr = []; let current = this.head; while (current) { arr.push(current); current = current.next; } return arr; }
    }

    PetiteVue.createApp({
        // --- 数据模型 ---
        list: new DoublyLinkedList(),
        currentNode: null,
        editingNode: null, // 追踪正在编辑的节点
        info: { title: '请开始操作', description: '请点击文档中的按钮，或移动光标，来观察链表的CRUD操作。', pointers: [], complexity: 'N/A' },

        init() {
            nodeIdCounter = 0;
            this.list = new DoublyLinkedList();
            ['第一阶段：市场调研', '第二阶段：原型设计 (UX)', '第三阶段：主功能开发', '第四阶段：上线与推广'].forEach(t => this.list.append(t));
            this.currentNode = this.list.head;
            this.updateInfo('init');
        },

        // --- C.R.U.D. 方法 ---

        // == READ (读取/遍历) ==
        moveUp() {
            if (this.currentNode && this.currentNode.prev) {
                this.updateInfo('read_prev', { from: this.currentNode, to: this.currentNode.prev });
                this.currentNode = this.currentNode.prev;
            }
        },
        moveDown() {
            if (this.currentNode && this.currentNode.next) {
                this.updateInfo('read_next', { from: this.currentNode, to: this.currentNode.next });
                this.currentNode = this.currentNode.next;
            }
        },

        // == CREATE (创建/插入) ==
        insertAfter(node) {
            const newNodeValue = `新任务...`;
            const newNode = this.list.insertAfter(node, newNodeValue);
            this.updateInfo('create', { target: node, newNode });
            this.currentNode = newNode; // 插入后，光标移动到新行
        },

        // == UPDATE (更新) ==
        startEditing(node) {
            this.editingNode = node;
            this.updateInfo('update_start', { target: node });
        },
        saveEdit(node) {
            if (this.editingNode === node) {
                 this.editingNode = null;
                 this.updateInfo('update_save', { target: node });
            }
        },

        // == DELETE (删除) ==
        deleteNode(node) {
            if (this.list.size <= 1) { this.updateInfo('error', { message: '文档至少需要保留一行。' }); return; }
            let nextCursor = node.prev || node.next;
            this.updateInfo('delete', { target: node });
            this.list.delete(node);
            this.currentNode = nextCursor;
        },

        // --- 超级教学模块 ---
        updateInfo(action, details = {}) {
            const name = (node) => `行${node.id+1}('${node.value.slice(0,10)}...')`;
            const code = (str) => `<span class="text-yellow-300">${str}</span>`;

            switch (action) {
                case 'init': this.info = { title: '编辑器已就绪', description: '文档已初始化为一个双向链表。每一行都是一个节点。光标所在行为当前节点。', pointers: [], complexity: '准备就绪' }; break;
                
                // READ
                case 'read_next': this.info = { title: 'READ: 读取下一节点', description: `光标下移。通过访问当前节点的 .next 指针，我们直接找到了下一行。`, pointers: [`currentNode = ${code('currentNode.next')}`], complexity: `<b>O(1) - 恒定时间</b>。无论文档多长，移动到下一行都是瞬间完成。` }; break;
                case 'read_prev': this.info = { title: 'READ: 读取上一节点', description: `光标上移。通过访问当前节点的 .prev 指针，我们直接找到了上一行。`, pointers: [`currentNode = ${code('currentNode.prev')}`], complexity: `<b>O(1) - 恒定时间</b>。双向链表让前后查找都极为高效。` }; break;
                
                // CREATE
                case 'create':
                    const oldNext = details.target.next;
                    this.info = { title: 'CREATE: 插入新节点', description: `在 ${name(details.target)} 后插入了一行新内容。`, pointers: [ `新节点.prev = ${code(name(details.target))}`, `新节点.next = ${code(oldNext ? name(oldNext) : 'NULL')}`, `${code(name(details.target))}.next = 新节点`, oldNext ? `${code(name(oldNext))}.prev = 新节点` : `(更新tail指针)`], complexity: `<b>O(1) - 恒定时间</b>。只修改了相邻的指针，无需移动任何其他行。这正是链表相比数组在插入操作上的巨大优势。` }; break;
                
                // UPDATE
                case 'update_start': this.info = { title: 'UPDATE: 更新节点(第1步)', description: `准备编辑 ${name(details.target)} 的内容。`, pointers: [`// 找到节点...`, `nodeToUpdate.value = ${code('"新内容..."')}`], complexity: `<b>O(1) - 更新操作本身</b>。一旦找到节点，修改其内容是瞬间的。查找节点可能需要 O(n) 时间，但在此例中我们直接操作，所以是O(1)。` }; break;
                case 'update_save': this.info = { title: 'UPDATE: 更新节点(第2步)', description: `已成功保存 ${name(details.target)} 的新内容。`, pointers: [`nodeToUpdate.value = ${code(`"${details.target.value}"`)}`], complexity: `<b>O(1) - 恒定时间</b>。节点的值被成功更新。` }; break;
                
                // DELETE
                case 'delete':
                    const prev = details.target.prev;
                    const next = details.target.next;
                    this.info = { title: 'DELETE: 删除节点', description: `删除了 ${name(details.target)}。`, pointers: [`if (node.prev) node.prev.next = ${code('node.next')}`, `if (node.next) node.next.prev = ${code('node.prev')}`], complexity: `<b>O(1) - 恒定时间</b>。删除操作只涉及修改前后两个“邻居”的指针，让它们互相“牵手”，从而“跳过”被删除的节点。` }; break;

                case 'error': this.info = { title: '操作不允许', description: details.message, pointers: [], complexity: 'N/A' }; break;
            }
        }
    }).mount('#app');
</script>

</body>
</html>