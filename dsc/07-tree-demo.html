<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>“树”结构概念浏览器 - ECharts 专业版</title>

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { background-color: #f8fafc; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    </style>
</head>
<body>

<div id="app" class="flex flex-col md:flex-row min-h-screen">
    
    <div class="flex-grow flex items-center justify-center p-4">
        <div id="echarts-tree-container" class="w-full h-full min-h-[500px]"></div>
    </div>

    <div class="w-full md:w-96 lg:w-1/3 max-w-md bg-white shadow-lg p-6 flex-shrink-0">
        <h1 class="text-2xl font-bold text-slate-800 mb-4">树 (Tree): 核心概念</h1>
        <ul class="space-y-1">
            <li @click="highlight('root')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">根节点 (Root)</strong><p class="text-sm text-slate-500">树的唯一顶层节点，是访问树的入口。</p></li>
            <li @click="highlight('leaf')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">叶子节点 (Leaf)</strong><p class="text-sm text-slate-500">没有任何子节点的“末梢”节点。</p></li>
            <li @click="highlight('parent')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">父/子节点 (Parent/Child)</strong><p class="text-sm text-slate-500">一个节点是其正下方节点的父，反之亦然。</p></li>
            <li @click="highlight('sibling')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">兄弟节点 (Sibling)</strong><p class="text-sm text-slate-500">拥有相同父节点的多个节点。</p></li>
            <li @click="highlight('edge')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">边 (Edge)</strong><p class="text-sm text-slate-500">代表两个节点之间直接关系的连接线。</p></li>
            <li @click="highlight('path')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">路径 (Path)</strong><p class="text-sm text-slate-500">从一个节点到另一个节点所经过的节点和边。</p></li>
            <li @click="highlight('subtree')" class="p-3 rounded-lg hover:bg-slate-100 transition cursor-pointer"><strong class="text-indigo-600">子树 (Subtree)</strong><p class="text-sm text-slate-500">一个节点及其所有后代组成的、本身也是一棵树的结构。</p></li>
        </ul>
        <button @click="clearHighlights" class="w-full mt-4 bg-slate-600 text-white font-semibold py-2 rounded-lg hover:bg-slate-700 transition">清除高亮</button>

        <div class="mt-8 pt-6 border-t">
            <h2 class="text-xl font-bold text-slate-700">描述指标</h2>
            <div class="mt-4 grid grid-cols-2 gap-x-4 gap-y-2 text-slate-600">
                <p><strong>节点总数 Total Nodes:</strong> <span class="font-mono font-bold text-blue-600">{{ metrics.totalNodes }}</span></p>
                <p><strong>叶子总数 Total Leaves:</strong> <span class="font-mono font-bold text-blue-600">{{ metrics.totalLeaves }}</span></p>
                <p><strong>树的高度 Height:</strong> <span class="font-mono font-bold text-blue-600">{{ metrics.height }}</span></p>
                <p><strong>树的度 Tree Degree:</strong> <span class="font-mono font-bold text-blue-600">{{ metrics.treeDegree }}</span></p>
            </div>
        </div>
    </div>
</div>

<script>
    const { createApp, ref, reactive, onMounted, onBeforeUnmount } = Vue;

    createApp({
        setup() {
            let chartInstance = null;
            const initialData = {
                name: 'A',
                children: [
                    { name: 'B', children: [ { name: 'D' }, { name: 'E', children: [{name: 'G'}] } ] },
                    { name: 'C', children: [ { name: 'F' } ] }
                ]
            };
            const metrics = reactive({ totalNodes: 0, totalLeaves: 0, height: -1, treeDegree: 0 });

            // --- Helper functions for data traversal ---
            const traverse = (node, callback) => {
                if (!node) return;
                callback(node);
                if (node.children) node.children.forEach(child => traverse(child, callback));
            };

            const findNode = (startNode, name) => {
                let found = null;
                traverse(startNode, node => { if (node.name === name) found = node; });
                return found;
            };

            const getPath = (startNode, endName) => {
                let path = [];
                const find = (node, targetName) => {
                    path.push(node.name);
                    if (node.name === targetName) return true;
                    if (node.children) {
                        for (const child of node.children) { if (find(child, targetName)) return true; }
                    }
                    path.pop();
                    return false;
                };
                find(startNode, endName);
                return path;
            };

            const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));

            const updateMetrics = () => {
                let nodeCount = 0, leafCount = 0, maxDegree = 0;
                const calculateHeight = (node) => {
                    if (!node) return -1;
                    if (!node.children || node.children.length === 0) return 0;
                    return 1 + Math.max(...node.children.map(calculateHeight));
                };
                traverse(initialData, node => {
                    nodeCount++;
                    const degree = node.children ? node.children.length : 0;
                    if (degree === 0) leafCount++;
                    if (degree > maxDegree) maxDegree = degree;
                });
                metrics.totalNodes = nodeCount;
                metrics.totalLeaves = leafCount;
                metrics.height = calculateHeight(initialData);
                metrics.treeDegree = maxDegree;
            };
            
            // --- ECharts Logic ---
            const baseOption = {
                tooltip: { trigger: 'item', triggerOn: 'mousemove' },
                series: [{
                    type: 'tree', data: [initialData],
                    symbol: 'circle', symbolSize: 40,
                    orient: 'TB', // BUG FIX: Set tree orientation to Top-to-Bottom
                    initialTreeDepth: -1,
                    label: { show: true, position: 'inside', fontSize: 14, color: '#333', formatter: '{b}' },
                    emphasis: {
                        focus: 'descendant',
                        itemStyle: { borderColor: '#a855f7', borderWidth: 4 },
                        lineStyle: { color: '#a855f7', width: 3 }
                    }
                }]
            };
            
            const highlight = (type) => {
                if (!chartInstance) return;
                clearHighlights();

                // SPECIAL CASE for highlighting a single edge, as it requires modifying data
                if (type === 'edge') {
                    const newData = deepCopy(initialData);
                    const targetNode = findNode(newData, 'F');
                    if(targetNode) {
                        targetNode.lineStyle = { color: '#f59e0b', width: 4 };
                    }
                    chartInstance.setOption({ series: [{ data: [newData] }] });
                    return;
                }

                // Default highlighting logic using dispatchAction
                let namesToHighlight = [];
                switch (type) {
                    case 'root': namesToHighlight = ['A']; break;
                    case 'leaf': traverse(initialData, n => { if (!n.children || n.children.length === 0) namesToHighlight.push(n.name); }); break;
                    case 'parent': namesToHighlight = ['B', 'D', 'E']; break;
                    case 'sibling': namesToHighlight = ['B', 'C']; break;
                    case 'path': namesToHighlight = getPath(initialData, 'G'); break;
                    case 'subtree':
                        const subtreeRoot = findNode(initialData, 'B');
                        traverse(subtreeRoot, n => namesToHighlight.push(n.name));
                        break;
                }
                
                chartInstance.dispatchAction({ type: 'highlight', seriesIndex: 0, name: namesToHighlight });
            };

            const clearHighlights = () => {
                if (!chartInstance) return;
                // Reset to base option to clear any data modifications (like edge style)
                chartInstance.setOption(baseOption, true); 
                // Downplay to clear any action-based highlights
                chartInstance.dispatchAction({ type: 'downplay', seriesIndex: 0 });
            };

            onMounted(() => {
                updateMetrics();
                const chartDom = document.getElementById('echarts-tree-container');
                chartInstance = echarts.init(chartDom);
                chartInstance.setOption(baseOption);
                
                const resizeHandler = () => chartInstance.resize();
                window.addEventListener('resize', resizeHandler);
                onBeforeUnmount(() => {
                    window.removeEventListener('resize', resizeHandler);
                    chartInstance.dispose();
                });
            });

            return { metrics, highlight, clearHighlights };
        }
    }).mount('#app');
</script>

</body>
</html>