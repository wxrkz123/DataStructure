<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>递归函数调用栈 - 深度工作原理演示</title>

    <!-- Dependencies -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        .notyf__message { color: #334155; }
        .code-line-wrapper { display: flex; align-items: flex-start; padding: 4px 10px; border-radius: 4px; transition: background-color 0.3s ease; font-size: 0.8rem; border-left: 3px solid transparent; }
        .code-line-wrapper.highlight { background-color: rgba(255, 255, 255, 0.15); border-left-color: #facc15; }
        .line-number { text-align: right; width: 1.5em; margin-right: 1.5em; color: #94a3b8; user-select: none; }
        .code-text { white-space: pre-wrap; font-weight: 500; flex: 1; }
        .stack-frame { transition: all 0.4s ease-in-out; transform-origin: center; border-left-width: 5px; }
        .param, .local-var { font-family: 'Courier New', Courier, monospace; background-color: #e0e7ff; color: #4338ca; padding: 2px 5px; border-radius: 4px; font-weight: bold; }
        .value { font-family: 'Courier New', Courier, monospace; background-color: #dcfce7; color: #15803d; padding: 2px 5px; border-radius: 4px; font-weight: bold; }
        .explanation-icon { font-size: 1.5rem; margin-right: 0.75rem; opacity: 0.8; }
        .return-value { margin-top: 8px; padding: 8px; border-radius: 6px; background-color: #f3e8ff; color: #7e22ce; text-align: center; font-weight: 600; font-size: 0.9rem; }
        .calculation-trace { font-family: 'Courier New', Courier, monospace; font-size: 1.25rem; font-weight: bold; text-align: center; padding: 1.5rem; }
    </style>
</head>
<body class="bg-slate-100">

<div id="app" class="flex flex-col h-screen p-4 gap-4">

    <!-- Header and Controls -->
    <header class="bg-white/90 backdrop-blur-lg shadow-lg rounded-xl p-4 z-20 shrink-0">
        <div class="max-w-7xl mx-auto">
            <h1 class="text-3xl font-bold text-slate-800 text-center mb-2">递归调用栈深度解析 - 以阶乘(Factorial)为例</h1>
            <p class="text-center text-slate-600 mb-4">手动控制递归的“递进”与“回溯”，彻底理解调用栈在递归中的核心作用。</p>
            <div class="flex justify-center items-center gap-4">
                 <button @click="startAnimation" :disabled="isBusy" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-5 rounded-md transition disabled:bg-slate-400 flex items-center gap-2">
                    <i class="fa-solid fa-play"></i> 演示 factorial(3)
                </button>
                 <button @click="reset" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-2 px-5 rounded-md transition flex items-center gap-2">
                    <i class="fa-solid fa-arrows-rotate"></i> 重置视图
                </button>
                 <button @click="nextStep" :disabled="!isBusy || isFinished" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-8 rounded-md transition disabled:bg-slate-400 flex items-center gap-2 text-lg">
                    下一步 <i class="fa-solid fa-forward-step"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-4 min-h-0">

        <!-- Left Panel: Code & Explanation -->
        <div class="bg-white shadow-lg rounded-xl p-4 flex flex-col min-h-0">
            <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 shrink-0">C 代码执行流程</h2>
            <div class="font-mono bg-slate-800 text-white p-3 rounded-lg text-sm overflow-auto mb-4">
                <div v-for="(line, index) in code" :key="index" :class="{'highlight': index === activeLine}" class="code-line-wrapper">
                    <span class="line-number">{{ index + 1 }}</span>
                    <span class="code-text" v-html="line.text"></span>
                </div>
            </div>
             <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 shrink-0">
                <i class="fa-solid fa-comment-dots text-sky-600"></i> 机制讲解
             </h2>
            <div class="flex-grow bg-sky-50 p-4 rounded-lg text-slate-800 overflow-y-auto">
                <div class="flex items-start">
                    <i :class="explanation.icon" class="explanation-icon text-sky-600"></i>
                    <p v-html="explanation.text" class="transition-opacity duration-300 flex-1"></p>
                </div>
            </div>
        </div>

        <!-- Center Panel: Calculation Trace -->
        <div class="bg-white shadow-lg rounded-xl p-4 flex flex-col min-h-0">
            <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 text-center shrink-0">计算过程追踪</h2>
            <div class="flex-grow flex items-center justify-center">
                 <div class="calculation-trace" v-html="calculationTrace"></div>
            </div>
        </div>

        <!-- Right Panel: Call Stack -->
        <div class="bg-white shadow-lg rounded-xl p-4 flex flex-col min-h-0">
            <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 shrink-0">调用栈 (Call Stack)</h2>
            <div class="flex-grow bg-slate-50 p-2 rounded-lg space-y-2 overflow-y-auto">
                 <div v-if="callStack.length === 0" class="text-center text-slate-500 pt-8">
                     <i class="fa-solid fa-layer-group text-4xl mb-2"></i>
                     <p>点击按钮开始演示</p>
                 </div>
                 <div v-for="(frame, index) in callStack" :key="frame.id" class="stack-frame bg-white p-3 rounded-lg shadow-md" :style="{ 'border-left-color': frame.color }">
                    <div class="flex justify-between items-center">
                        <span class="font-bold text-slate-800 text-lg">{{ frame.functionName }}</span>
                        <span class="text-xs font-mono text-white px-2 py-0.5 rounded-full" :class="frame.statusClass">{{ frame.statusText }}</span>
                    </div>
                    <hr class="my-2">
                    <div class="text-sm space-y-2 font-mono">
                       <p><strong>参数:</strong> <span class="param">n</span> = <span class="value">{{ frame.n }}</span></p>
                       <p v-if="frame.pendingOp"><strong>待定操作:</strong> <span v-html="frame.pendingOp"></span></p>
                    </div>
                    <div v-if="frame.returnValue !== undefined" class="return-value">
                        <i class="fa-solid fa-arrow-left-long"></i> 返回值: <span class="value">{{ frame.returnValue }}</span>
                    </div>
                 </div>
            </div>
        </div>

    </main>
</div>

<script>
    const { createApp, ref, reactive, onMounted } = Vue;

    createApp({
        setup() {
            const isBusy = ref(false);
            const isFinished = ref(true);
            const notyf = new Notyf({ duration: 2000, position: { x: 'top', y: 'center' } });

            const explanation = ref({ text: '点击“演示 factorial(3)”按钮，开始探索递归的奥秘。', icon: 'fa-solid fa-circle-info' });
            const activeLine = ref(-1);
            const callStack = ref([]);
            const calculationTrace = ref('result = ?');
            const animationSteps = ref([]);
            const currentStepIndex = ref(-1);
            
            const code = ref([
                { text: `long long factorial(int n) {` },
                { text: `    // 基本情况(Base Case): 递归的出口` },
                { text: `    if (n <= 1) {` },
                { text: `        return 1;` },
                { text: `    }` },
                { text: ` ` },
                { text: `    // 递归步骤(Recursive Step)` },
                { text: `    return n * factorial(n - 1);` },
                { text: `}` },
                { text: ` ` },
                { text: `int main() {` },
                { text: `    long long result = factorial(3);` },
                { text: `    return 0;` },
                { text: `}` },
            ]);
            
            const reset = () => {
                isBusy.value = false; isFinished.value = true;
                animationSteps.value = []; currentStepIndex.value = -1;
                callStack.value = []; activeLine.value = -1;
                explanation.value = { text: '点击“演示 factorial(3)”按钮，开始探索递归的奥秘。', icon: 'fa-solid fa-circle-info' };
                calculationTrace.value = 'result = ?';
                notyf.success('视图已重置。');
            };
            
            // This is the heart of the logic, defining every single step
            const generateAnimationSteps = () => {
                const colors = ['#3b82f6', '#16a34a', '#f97316', '#8b5cf6'];
                let steps = [];

                // Main calls factorial(3)
                steps.push({ line: 12, exp: '程序从`main`开始。准备调用`factorial(3)`。', 
                    action: { type: 'stackPush', frame: {id: 1, color: '#64748b', functionName: 'main', n: '', statusText: '调用中...', statusClass: 'bg-amber-500'} },
                    trace: 'result = factorial(3)'
                });
                steps.push({ line: 1, exp: '`main`暂停。为`factorial(3)`创建新栈帧并压栈。控制权转移至`factorial`。', 
                    action: { type: 'stackPush', frame: {id: 2, color: colors[0], functionName: 'factorial', n: 3, statusText: '执行中', statusClass: 'bg-blue-600'} }
                });

                // Inside factorial(3)
                steps.push({ line: 3, exp: '检查基本情况: `n`(<span class="value">3</span>) > 1，条件为假。', action: { type: 'nothing' } });
                steps.push({ line: 8, exp: '执行递归步骤。<b>核心点：</b>为了计算 `3 * factorial(2)`，必须先完成`factorial(2)`的调用。', 
                    trace: 'result = 3 * factorial(2)'
                });
                steps.push({ line: 8, exp: '`factorial(3)`暂停执行，等待`factorial(2)`的返回值。其当前状态和待定操作被保存在它的栈帧中。', 
                    action: { type: 'updateStatus', statusText: '等待返回', statusClass: 'bg-slate-500', pendingOp: '3 * ?' } 
                });
                steps.push({ line: 1, exp: '为`factorial(2)`创建新栈帧并压栈。控制权再次转移至`factorial`函数自身。', 
                    action: { type: 'stackPush', frame: {id: 3, color: colors[1], functionName: 'factorial', n: 2, statusText: '执行中', statusClass: 'bg-blue-600'} }
                });
                
                // Inside factorial(2)
                steps.push({ line: 3, exp: '检查基本情况: `n`(<span class="value">2</span>) > 1，条件为假。', action: { type: 'nothing' } });
                steps.push({ line: 8, exp: '执行递归步骤。同样，为了计算 `2 * factorial(1)`，必须先完成`factorial(1)`的调用。',
                    trace: 'result = 3 * (2 * factorial(1))'
                });
                 steps.push({ line: 8, exp: '`factorial(2)`暂停执行，等待`factorial(1)`的返回值。', 
                    action: { type: 'updateStatus', statusText: '等待返回', statusClass: 'bg-slate-500', pendingOp: '2 * ?' } 
                });
                steps.push({ line: 1, exp: '为`factorial(1)`创建新栈帧并压栈。调用栈达到最大深度。', 
                    action: { type: 'stackPush', frame: {id: 4, color: colors[2], functionName: 'factorial', n: 1, statusText: '执行中', statusClass: 'bg-blue-600'} }
                });

                // Base Case: factorial(1)
                steps.push({ line: 3, exp: '<b>递归的出口：</b>检查基本情况: `n`(<span class="value">1</span>) <= 1，条件为<b>真</b>！', action: { type: 'nothing' } });
                steps.push({ line: 4, exp: '命中基本情况，函数直接返回常量`1`。递归的“递进”阶段结束，开始“回溯”阶段。',
                    action: { type: 'setReturn', value: 1, statusText: '返回值', statusClass: 'bg-purple-600'} 
                });

                // Unwinding phase: return to factorial(2)
                steps.push({ line: 8, exp: '`factorial(1)`执行完毕，其栈帧被弹出。控制权和返回值`1`交还给调用者`factorial(2)`。',
                    action: { type: 'stackPop' }
                });
                steps.push({ line: 8, exp: '`factorial(2)`恢复执行。它接收到返回值`1`，完成其待定操作: <span class="value">2 * 1</span>。',
                    action: { type: 'updateStatus', statusText: '计算中...', statusClass: 'bg-blue-600'},
                    trace: 'result = 3 * (2 * 1)'
                });
                steps.push({ line: 8, exp: '计算完成，`factorial(2)`准备返回结果`2`。',
                     action: { type: 'setReturn', value: 2, statusText: '返回值', statusClass: 'bg-purple-600'} 
                });
                
                 // Unwinding phase: return to factorial(3)
                steps.push({ line: 8, exp: '`factorial(2)`执行完毕，其栈帧被弹出。控制权和返回值`2`交还给`factorial(3)`。',
                    action: { type: 'stackPop' }
                });
                steps.push({ line: 8, exp: '`factorial(3)`恢复执行，接收到返回值`2`，完成其待定操作: <span class="value">3 * 2</span>。',
                     action: { type: 'updateStatus', statusText: '计算中...', statusClass: 'bg-blue-600'},
                     trace: 'result = 3 * 2'
                });
                 steps.push({ line: 8, exp: '计算完成，`factorial(3)`准备返回最终结果`6`。',
                     action: { type: 'setReturn', value: 6, statusText: '返回值', statusClass: 'bg-purple-600'} 
                });

                // Return to main
                 steps.push({ line: 12, exp: '`factorial(3)`执行完毕，其栈帧被弹出。控制权和最终返回值`6`交还给`main`。',
                    action: { type: 'stackPop' }
                });
                 steps.push({ line: 12, exp: '`main`恢复执行，接收到返回值`6`，并赋给变量`result`。',
                    action: { type: 'updateStatus', statusText: '执行中', statusClass: 'bg-blue-600'},
                    trace: 'result = 6'
                });
                steps.push({ line: 13, exp: '`main`执行完毕，准备返回`0`。',
                     action: { type: 'setReturn', value: 0, statusText: '返回值', statusClass: 'bg-purple-600'} 
                });
                steps.push({ line: 14, exp: '`main`的栈帧被弹出，调用栈清空，程序执行结束。',
                    action: { type: 'stackPop' },
                });
                animationSteps.value = steps;
            };

            const startAnimation = () => {
                if (isBusy.value) return;
                reset();
                generateAnimationSteps();
                isBusy.value = true;
                isFinished.value = false;
                notyf.success(`已生成 ${animationSteps.value.length} 个动画步骤。`);
                nextStep();
            };

            const nextStep = () => {
                if (currentStepIndex.value >= animationSteps.value.length - 1) {
                    isFinished.value = true;
                    notyf.success('演示已结束！');
                    return;
                }
                
                currentStepIndex.value++;
                const step = animationSteps.value[currentStepIndex.value];

                explanation.value = step.exp || explanation.value;
                activeLine.value = step.line !== undefined ? step.line - 1 : activeLine.value;
                if(step.trace) calculationTrace.value = step.trace;
                
                const processAction = (action) => {
                    if (!action || !action.type) return;
                    let frame = callStack.value.length > 0 ? callStack.value[0] : null;

                    switch (action.type) {
                        case 'stackPush': callStack.value.unshift(action.frame); break;
                        case 'stackPop': callStack.value.shift(); break;
                        case 'updateStatus': Object.assign(frame, { statusText: action.statusText, statusClass: action.statusClass, pendingOp: action.pendingOp || frame.pendingOp }); break;
                        case 'setReturn': Object.assign(frame, { returnValue: action.value, statusText: action.statusText, statusClass: action.statusClass }); break;
                        case 'nothing': break;
                    }
                };

                processAction(step.action);
            };
            
            onMounted(() => { reset(); });

            return { isBusy, isFinished, explanation, activeLine, code, callStack, calculationTrace, startAnimation, reset, nextStep };
        }
    }).mount('#app');
</script>

</body>
</html>