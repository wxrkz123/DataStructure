<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BST 递归插入过程 - 手动分步深度解析</title>

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        .notyf__message { color: #334155; }
        .code-line-wrapper {
            display: flex;
            align-items: flex-start;
            padding: 4px 10px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            font-size: 0.8rem;
            border-left: 3px solid transparent;
        }
        .code-line-wrapper.highlight {
            background-color: rgba(255, 255, 255, 0.15);
            border-left-color: #facc15;
        }
        .line-number {
            text-align: right;
            width: 1.5em;
            margin-right: 1.5em;
            color: #94a3b8;
            user-select: none;
        }
        .code-text {
            white-space: pre-wrap;
            font-weight: 500;
            flex: 1;
        }
        .code-line-wrapper.highlight .code-text {
            font-weight: bold;
        }
        .stack-frame {
            transition: all 0.4s ease-in-out;
            transform-origin: center;
        }
        .address {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e0e7ff;
            color: #4338ca;
            padding: 2px 5px;
            border-radius: 4px;
            font-weight: bold;
        }
        .value {
            font-family: 'Courier New', Courier, monospace;
            background-color: #dcfce7;
            color: #15803d;
            padding: 2px 5px;
            border-radius: 4px;
            font-weight: bold;
        }
        .explanation-icon {
            font-size: 1.5rem;
            margin-right: 0.75rem;
            opacity: 0.8;
        }
    </style>
</head>
<body class="bg-slate-100">

<div id="app" class="flex flex-col h-screen p-4 gap-4">

    <!-- Header and Controls -->
    <header class="bg-white/90 backdrop-blur-lg shadow-lg rounded-xl p-4 z-20 shrink-0">
        <div class="max-w-7xl mx-auto">
            <h1 class="text-3xl font-bold text-slate-800 text-center mb-2">BST 递归插入 - 手动分步深度解析</h1>
            <p class="text-center text-slate-600 mb-4">通过手动控制每一步，观察调用栈、代码和树的变化，彻底搞懂递归。</p>
            <div class="flex justify-center items-center gap-4">
                <input type="number" v-model.number="inputs.value" placeholder="输入数值" @keyup.enter="startAnimation" :disabled="isBusy" class="w-32 px-3 py-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 transition">
                <button @click="startAnimation" :disabled="isBusy" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-5 rounded-md transition disabled:bg-slate-400 flex items-center gap-2">
                    <i class="fa-solid fa-wand-magic-sparkles"></i> 准备演示
                </button>
                 <button @click="resetTree" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-2 px-5 rounded-md transition flex items-center gap-2">
                    <i class="fa-solid fa-arrows-rotate"></i> 重置视图
                </button>
                 <button @click="nextStep" :disabled="!isBusy || isFinished" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-8 rounded-md transition disabled:bg-slate-400 flex items-center gap-2 text-lg">
                    下一步 <i class="fa-solid fa-forward-step"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-4 min-h-0">

        <!-- Left Panel: Code & Explanation -->
        <div class="bg-white shadow-lg rounded-xl p-4 flex flex-col min-h-0">
            <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 shrink-0">C 代码执行流程</h2>
            <div class="font-mono bg-slate-800 text-white p-3 rounded-lg text-sm overflow-auto mb-4">
                <div v-for="(line, index) in code" :key="index" :class="{'highlight': index === activeLine}" class="code-line-wrapper">
                    <span class="line-number">{{ index + 1 }}</span>
                    <span class="code-text">{{ line.text }}</span>
                </div>
            </div>
             <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 shrink-0">
                <i class="fa-solid fa-comment-dots text-sky-600"></i> 动画讲解
             </h2>
            <div class="flex-grow bg-sky-50 p-4 rounded-lg text-slate-800 overflow-y-auto">
                <div class="flex items-start">
                    <i :class="explanation.icon" class="explanation-icon text-sky-600"></i>
                    <p v-html="explanation.text" class="transition-opacity duration-300 flex-1"></p>
                </div>
            </div>
        </div>

        <!-- Center Panel: BST Visualization -->
        <div class="bg-white shadow-lg rounded-xl p-4 flex flex-col min-h-0">
            <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 text-center shrink-0">二叉搜索树 (ECharts)</h2>
            <div id="echarts-bst-container" class="w-full flex-grow min-h-0"></div>
        </div>

        <!-- Right Panel: Call Stack -->
        <div class="bg-white shadow-lg rounded-xl p-4 flex flex-col min-h-0">
            <h2 class="text-xl font-bold text-slate-700 mb-2 border-b pb-2 shrink-0">调用栈 (Call Stack)</h2>
            <div class="flex-grow bg-slate-50 p-2 rounded-lg space-y-2 overflow-y-auto">
                 <div v-if="callStack.length === 0" class="text-center text-slate-500 pt-8">
                     <i class="fa-solid fa-layer-group text-4xl mb-2"></i>
                     <p>动画开始后，这里将显示调用栈</p>
                 </div>
                 <div v-for="(frame, index) in callStack" :key="frame.id" class="stack-frame bg-white p-3 rounded-lg shadow-md" :style="{ 'border-left': `5px solid ${frame.color}` }">
                    <div class="flex justify-between items-center">
                        <span class="font-bold text-slate-800">{{ frame.functionName }}</span>
                        <span class="text-xs font-mono text-white px-2 py-0.5 rounded-full" :class="frame.statusClass">{{ frame.statusText }}</span>
                    </div>
                    <hr class="my-2">
                    <div class="text-sm space-y-1 font-mono">
                        <p><strong>node:</strong> <span class="address">{{ frame.nodeAddress }}</span></p>
                        <p><strong>data:</strong> <span class="value">&{{ frame.data }}</span></p>
                    </div>
                    <div v-if="frame.returnValue" class="mt-2 p-2 rounded-md bg-purple-100 text-purple-800 text-sm font-semibold text-center">
                        <i class="fa-solid fa-arrow-left-long"></i> 返回值: <span class="address">{{ frame.returnValue }}</span>
                    </div>
                 </div>
            </div>
        </div>

    </main>
</div>

<script>
    const { createApp, ref, reactive, onMounted, onBeforeUnmount } = Vue;

    class BstNode {
        constructor(value, address) {
            this.value = value;
            this.address = address;
            this.left = null;
            this.right = null;
            this.highlight = null;
        }
    }

    createApp({
        setup() {
            let chartInstance = null;
            const root = ref(null);
            const isBusy = ref(false);
            const isFinished = ref(false);
            const inputs = reactive({ value: 7 });
            const notyf = new Notyf({ duration: 2000, position: { x: 'top', y: 'center' } });

            const explanation = ref({ text: '在上方输入框中输入一个数字（例如 7），然后点击“准备演示”来生成动画步骤。', icon: 'fa-solid fa-circle-info' });
            const activeLine = ref(-1);
            const callStack = ref([]);
            const animationSteps = ref([]);
            const currentStepIndex = ref(-1);
            
            let memoryCounter = 0x1000;
            const allocateAddress = () => {
                const addr = `0x${(memoryCounter).toString(16).toUpperCase()}`;
                memoryCounter += Math.floor(Math.random() * 12 + 8) * 8;
                return addr;
            };

            const code = ref([
                { text: "static Node* _insert_recursive(BST* bst, Node* node, const void* data) {" },
                { text: "    // 基本情况：如果当前节点为空，我们找到了插入位置。" },
                { text: "    if (node == NULL) {" },
                
                { text: "        bst->size++;" },
                
                { text: "        return _create_node(data, bst->element_size);" },
                { text: "    }" },
                { text: "" },
                { text: "    int cmp = bst->compare(data, node->data);" },
                { text: "" },
                { text: "    if (cmp < 0) {" },
                { text: "        // 新数据比当前节点小，递归地插入到左子树" },
                { text: "        node->left = _insert_recursive(bst, node->left, data);" },
                { text: "    } else if (cmp > 0) {" },
                { text: "        // 新数据比当前节点大，递归地插入到右子树" },
                { text: "        node->right = _insert_recursive(bst, node->right, data);" },
                { text: "    }" },
                { text: "" },
                { text: "    // 如果 cmp == 0，说明数据已存在，直接返回原节点。" },
                { text: "    return node; // 返回当前子树的根" },
                { text: "}" },
            ]);
            
            // --- CORE LOGIC & HELPERS ---
            const findNodeByAddress = (node, address) => {
                if (!node) return null;
                if (node.address === address) return node;
                return findNodeByAddress(node.left, address) || findNodeByAddress(node.right, address);
            };

            const createNodeFromData = (data) => {
                if (!data) return null;
                const node = new BstNode(data.value, data.address);
                node.left = createNodeFromData(data.left);
                node.right = createNodeFromData(data.right);
                return node;
            };

            const transformToEchartsData = (bstNode) => {
                if (!bstNode) return null;
                const data = {
                    name: `${bstNode.value}\n(${bstNode.address})`,
                    itemStyle: {},
                    tooltip: { formatter: () => `<strong>值:</strong> ${bstNode.value}<br><strong>地址:</strong> <span class="address">${bstNode.address}</span>` },
                    children: []
                };
                const colors = {
                    current: { border: '#ef4444', bg: '#fee2e2', width: 4 },
                    path: { border: '#f59e0b', bg: '#fef3c7', width: 3 },
                    new: { border: '#22c55e', bg: '#dcfce7', width: 4 },
                    final: { border: '#8b5cf6', bg: '#ede9fe', width: 4},
                    default: { border: '#64748b', bg: '#f1f5f9', width: 2 }
                };
                const style = colors[bstNode.highlight] || colors.default;
                data.itemStyle = { borderColor: style.border, color: style.bg, borderWidth: style.width };

                const leftChild = transformToEchartsData(bstNode.left);
                const rightChild = transformToEchartsData(bstNode.right);
                if (leftChild || rightChild) {
                    data.children.push(leftChild || { name: '', symbol: 'none' });
                    data.children.push(rightChild || { name: '', symbol: 'none' });
                }
                return data;
            };

            const updateChart = () => {
                 if (!chartInstance) return;
                 const data = root.value ? [transformToEchartsData(root.value)] : [];
                 // --- FIX: Removed `{ notMerge: true }` for more stable rendering during structural changes ---
                 chartInstance.setOption({ series: [{ data }] });
            };
            
            // --- ANIMATION LOGIC ---
            const startAnimation = () => {
                if (typeof inputs.value !== 'number') {
                    notyf.error('请输入一个有效的数值。');
                    return;
                }
                resetAnimationState();
                isBusy.value = true;
                
                const valueToInsert = inputs.value;
                inputs.value = null;

                if (findNodeByAddress(root.value, valueToInsert)) {
                    notyf.error(`值 ${valueToInsert} 已存在于树中！`);
                    isBusy.value = false;
                    return;
                }
                
                let steps = [];
                let stackFrameIdCounter = 0;
                const simulationTree = JSON.parse(JSON.stringify(root.value));

                function trace(node, data) {
                    const frameId = ++stackFrameIdCounter;
                    const frameColor = ['#3b82f6', '#16a34a', '#f97316', '#8b5cf6', '#d946ef'][(frameId-1) % 5];
                    const nodeAddress = node ? node.address : 'NULL';
                    const nodeValue = node ? node.value : null;
                    
                    steps.push({ line: 1, explanation: { text: `进入函数... 新的栈帧 <b>#${frameId}</b> 被压入。`, icon: 'fa-solid fa-right-to-bracket'},
                        action: { type: 'stackPush', frame: { id: frameId, functionName: `调用 #${frameId}`, nodeAddress, data, statusText: '执行中', statusClass: 'bg-blue-600', color: frameColor } }
                    });
                    if (node) steps.push({ action: { type: 'highlight', address: nodeAddress, style: 'current' } });
                    
                    steps.push({ line: 3, explanation: { text: `检查 <code>node == NULL</code>... 当前 <code>node</code> 是 <span class="address">${nodeAddress}</span>.`, icon: 'fa-solid fa-circle-question' } });

                    if (node == null) {
                        const newNodeAddress = allocateAddress();
                        steps.push({ line: 3, explanation: { text: `条件为 <b>真</b>！命中基本情况。`, icon: 'fa-solid fa-check-double' },
                            action: { type: 'stackUpdate', statusText: '命中基线', statusClass: 'bg-green-600' }
                        });
                        steps.push({ line: 5, explanation: { text: `创建新节点，值为 <span class="value">${data}</span>，地址为 <span class="address">${newNodeAddress}</span>。`, icon: 'fa-solid fa-microchip' }});
                        steps.push({ line: 5, explanation: { text: `函数返回<b>新节点地址</b> <span class="address">${newNodeAddress}</span>。栈帧 <b>#${frameId}</b> 出栈。`, icon: 'fa-solid fa-arrow-left-long' },
                            action: { type: 'stackUpdate', statusText: '返回新地址', statusClass: 'bg-purple-600', returnValue: newNodeAddress }
                        });
                        steps.push({ action: { type: 'stackPop' } });
                        return { value: data, address: newNodeAddress, left: null, right: null };
                    }
                    
                    steps.push({ line: 8, explanation: { text: `条件为 <b>假</b>。比较 <span class="value">${data}</span> vs <span class="value">${nodeValue}</span>。`, icon: 'fa-solid fa-code-compare' },
                         action: { type: 'stackUpdate', statusText: `比较 ${data} vs ${nodeValue}`, statusClass: 'bg-amber-500' }
                    });

                    if (data < node.value) {
                        steps.push({ line: 10, explanation: { text: `结果为<b>负</b>，向<b>左子树</b>递归。`, icon: 'fa-solid fa-arrow-left' } });
                        steps.push({ line: 12, explanation: { text: `<b>核心点</b>: 当前函数<b>暂停</b>，等待左路递归调用返回地址...`, icon: 'fa-solid fa-hourglass-half' },
                            action: { type: 'multi', actions: [
                                { type: 'highlight', address: nodeAddress, style: 'path' },
                                { type: 'stackUpdate', statusText: '等待左路返回', statusClass: 'bg-slate-500' }
                            ]}
                        });

                        const returnedChild = trace(node.left, data);
                        node.left = returnedChild;
                        
                        steps.push({ line: 12, explanation: { text: `<b>调用返回！</b> 左路返回地址 <span class="address">${returnedChild.address}</span>。执行赋值: <code>node->left = ...</code>`, icon: 'fa-solid fa-link' },
                             action: { type: 'multi', actions: [
                                { type: 'stackRestore', frame: { id: frameId, functionName: `调用 #${frameId}`, nodeAddress, data, statusText: '恢复执行', statusClass: 'bg-blue-600', color: frameColor }},
                                { type: 'link', parentAddress: nodeAddress, direction: 'left', childData: returnedChild },
                                { type: 'highlight', address: nodeAddress, style: 'current' },
                                { type: 'highlight', address: returnedChild.address, style: 'final' }
                             ]}
                        });
                    } else {
                         steps.push({ line: 13, explanation: { text: `结果为<b>正</b>，向<b>右子树</b>递归。`, icon: 'fa-solid fa-arrow-right' } });
                         steps.push({ line: 15, explanation: { text: `<b>核心点</b>: 当前函数<b>暂停</b>，等待右路递归调用返回地址...`, icon: 'fa-solid fa-hourglass-half' },
                            action: { type: 'multi', actions: [
                                { type: 'highlight', address: nodeAddress, style: 'path' },
                                { type: 'stackUpdate', statusText: '等待右路返回', statusClass: 'bg-slate-500' }
                            ]}
                        });
                        
                        const returnedChild = trace(node.right, data);
                        node.right = returnedChild;

                        steps.push({ line: 15, explanation: { text: `<b>调用返回！</b> 右路返回地址 <span class="address">${returnedChild.address}</span>。执行赋值: <code>node->right = ...</code>`, icon: 'fa-solid fa-link' },
                            action: { type: 'multi', actions: [
                                { type: 'stackRestore', frame: { id: frameId, functionName: `调用 #${frameId}`, nodeAddress, data, statusText: '恢复执行', statusClass: 'bg-blue-600', color: frameColor }},
                                { type: 'link', parentAddress: nodeAddress, direction: 'right', childData: returnedChild },
                                { type: 'highlight', address: nodeAddress, style: 'current' },
                                { type: 'highlight', address: returnedChild.address, style: 'final' }
                             ]}
                        });
                    }

                    steps.push({ line: 19, explanation: { text: `工作完成。返回<b>当前节点地址</b> <span class="address">${nodeAddress}</span>。`, icon: 'fa-solid fa-arrow-left-long' },
                         action: { type: 'stackUpdate', statusText: '返回原地址', statusClass: 'bg-purple-600', returnValue: nodeAddress }
                    });
                    steps.push({ action: { type: 'stackPop' } });
                    return node;
                }
                
                trace(simulationTree, valueToInsert);

                steps.push({ line: -1, explanation: { text: `<b>全部完成!</b> 调用栈已清空，节点 <span class="value">${valueToInsert}</span> 已成功插入！`, icon: 'fa-solid fa-party-horn' },
                    action: { type: 'clearHighlights' }
                });

                animationSteps.value = steps;
                notyf.success(`已为插入 ${valueToInsert} 生成 ${steps.length} 个动画步骤。`);
                nextStep();
            };

            const nextStep = () => {
                if (currentStepIndex.value >= animationSteps.value.length - 1) {
                    isFinished.value = true;
                    notyf.success('演示已结束！');
                    return;
                }
                
                currentStepIndex.value++;
                const step = animationSteps.value[currentStepIndex.value];

                explanation.value = step.explanation || explanation.value;
                activeLine.value = step.line !== undefined ? step.line - 1 : -1;
                
                const processAction = (action) => {
                    if (!action) return;
                    switch (action.type) {
                        case 'highlight': {
                            const node = findNodeByAddress(root.value, action.address);
                            if(node) node.highlight = action.style;
                            break;
                        }
                        case 'clearHighlights': {
                            const clear = (n) => { if(n) { n.highlight = null; clear(n.left); clear(n.right); }};
                            clear(root.value);
                            break;
                        }
                        case 'link': {
                            const parent = findNodeByAddress(root.value, action.parentAddress);
                            if (parent) {
                                const childSubtree = createNodeFromData(action.childData);
                                parent[action.direction] = childSubtree;
                            }
                            break;
                        }
                        case 'stackPush': callStack.value.unshift(action.frame); break;
                        case 'stackPop': callStack.value.shift(); break;
                        case 'stackUpdate': Object.assign(callStack.value[0], action); break;
                        case 'stackRestore': callStack.value[0] = action.frame; break;
                        case 'multi': action.actions.forEach(processAction); break;
                    }
                };

                processAction(step.action);
                updateChart();
            };
            
            const resetAnimationState = () => {
                isBusy.value = false; isFinished.value = false;
                animationSteps.value = []; currentStepIndex.value = -1;
                callStack.value = []; activeLine.value = -1;
                explanation.value = { text: '在上方输入框中输入一个数字，然后点击“准备演示”来生成动画步骤。', icon: 'fa-solid fa-circle-info' };
            };
            
            const resetTree = () => {
                resetAnimationState();
                memoryCounter = 0x1000;
                root.value = new BstNode(10, allocateAddress());
                root.value.left = new BstNode(5, allocateAddress());
                root.value.right = new BstNode(20, allocateAddress());
                updateChart();
                notyf.success('树已重置为 {10, 5, 20}。');
            };

            onMounted(() => {
                chartInstance = echarts.init(document.getElementById('echarts-bst-container'));
                chartInstance.setOption({
                    tooltip: { trigger: 'item', triggerOn: 'mousemove', confine: true, backgroundColor: 'rgba(255,255,255,0.95)', borderWidth: 1, borderColor: '#e2e8f0' },
                    series: [{
                        type: 'tree', data: [], symbol: 'circle', symbolSize: 70, orient: 'TB', edgeShape: 'curve',
                        initialTreeDepth: -1, expandAndCollapse: false,
                        label: { show: true, position: 'inside', fontSize: 12, color: '#0f172a', fontWeight: 'bold' },
                        lineStyle: { color: '#64748b', width: 2 },
                        emphasis: { disabled: true }
                    }]
                });
                resetTree();
                window.addEventListener('resize', () => chartInstance && chartInstance.resize());
            });

            return { isBusy, isFinished, inputs, explanation, activeLine, code, callStack, startAnimation, resetTree, nextStep };
        }
    }).mount('#app');
</script>

</body>
</html>